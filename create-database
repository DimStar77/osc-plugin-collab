#!/usr/bin/env python
# vim: set ts=4 sw=4 et: coding=UTF-8

#
# Copyright (c) 2008, Novell, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#  * Neither the name of the <ORGANIZATION> nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#
# (Licensed under the simplified BSD license)
#
# Authors: Vincent Untz <vuntz@novell.com>
#

import os
import sys

import optparse
import re
import sqlite3
import tempfile

try:
    from lxml import etree as ET
except ImportError:
    try:
        from xml.etree import cElementTree as ET
    except ImportError:
        import cElementTree as ET

# This script was originally written for an usage with autobuild. It has been
# adapted for the build service, but a few features might still need to be
# ported. TODO-BS or FIXME-BS might indicate them.

if os.getenv('OBS_DISSECTOR_DIR') and os.getenv('OBS_DISSECTOR_DIR') != '':
    OBS_DISSECTOR_DIR=os.getenv('OBS_DISSECTOR_DIR')
else:
    OBS_DISSECTOR_DIR='/tmp/obs-dissector'


# Where to look for packages. Note that the structure has to be
# PACKAGE_LOOKUP_PATH/$project/$package
# Use the obs-checkout script to populate such a directory.
PACKAGE_LOOKUP_PATH = os.path.join(OBS_DISSECTOR_DIR, 'obs-co-stable')

MODULE_SRCPACKAGE_MATCH_FILE = os.path.join(OBS_DISSECTOR_DIR, 'upstream-packages-match.txt')
UPSTREAM_VERSIONS_FALLBACK_FILE = os.path.join(OBS_DISSECTOR_DIR, 'upstream-versions-fallback.txt')

# Files to just ignore in the file list of a package.
IGNORE_FILES = [ 'ready', 'MD5SUMS', 'MD5SUMS.meta' ]

# Would be nice to get the list of failed package builds. In autobuild, look
# at /work/built/info/failed/ TODO-BS

# In autobuild, it's easy to get access to the rpmlint reports. Keep this empty
# until we find an easy way to do the same for the build service (maybe just
# parse the output of the build log?)
RPMLINT_ERRORS_PATH = os.path.join(OBS_DISSECTOR_DIR, 'tmp', 'rpmlint')

# Changing this means breaking compatibility with previous db
DB_MAJOR = 3
# Changing this means changing the db while keeping compatibility
# Increase when changing the db. Reset to 0 when changing DB_MAJOR.
DB_MINOR = 3


#######################################################################

class DataCache:
    def __init__(self, upstream_name, upstream_versions_fallback):
        self.db = sqlite3.connect(':memory:')
        self.cursor = self.db.cursor()

        self.upstream_versions_fallback = {}

        self._sql_setup()
        self._fill_upstream_name(upstream_name)
        self._fill_upstream_versions_fallback(upstream_versions_fallback)

    def _sql_setup(self):
        self.cursor.execute('''CREATE TABLE upstream_name (
            id INTEGER PRIMARY KEY,
            srcpackage TEXT,
            upstream TEXT
            );''')
        self.cursor.execute('''CREATE TABLE upstream_version (
            id INTEGER PRIMARY KEY,
            upstream_version_file INTEGER,
            upstream TEXT,
            version TEXT,
            url TEXT
            );''')
        self.cursor.execute('''CREATE TABLE upstream_version_file (
            id INTEGER PRIMARY KEY,
            file TEXT
            );''')


    def _is_line_comment(self, line):
        return line[0] == '#' or line.strip() == ''


    def _fill_upstream_name(self, upstream_name):
        if not os.path.exists(upstream_name):
            print >> sys.stderr, 'No upstream name database available.'
            return

        file = open(upstream_name)
        re_upstream_name = re.compile('^(.+):(.*)$')
        while True:
            line = file.readline()

            if len(line) == 0:
                break
            if self._is_line_comment(line):
                continue

            match = re_upstream_name.match(line)
            if match:
                upstream = match.group(1)
                if match.group(2) != '':
                    srcpackage = match.group(2)
                else:
                    srcpackage = upstream
                self.cursor.execute('''INSERT INTO upstream_name VALUES (
                    NULL, ?, ?
                    );''',
                    (srcpackage, upstream))

        file.close()

    def _fill_upstream_versions_fallback(self, upstream_versions_fallback):
        if not os.path.exists(upstream_versions_fallback):
            return

        file = open(upstream_versions_fallback)
        lines = file.readlines()
        file.close()

        for line in lines:
            line = line[:-1]
            fields = line.split(',')
            if len(fields) < 2:
                continue
            self.upstream_versions_fallback[fields[0]] = fields[1]

    def _get_upstream_version_file_id(self, upstream_version_file):
        self.cursor.execute('''SELECT id FROM upstream_version_file WHERE
            file = ?;''', (upstream_version_file,))
        row = self.cursor.fetchone()
        if row:
            return row[0]
        else:
            return ''


    def fill_upstream_version(self, upstream_version_file):
        # check if we already cached this file
        file_id = self._get_upstream_version_file_id(upstream_version_file)
        if file_id:
            return

        self.cursor.execute('''INSERT INTO upstream_version_file VALUES (
            NULL, ?
            );''',
            (upstream_version_file,))
        self.cursor.execute('''SELECT MAX(id) FROM upstream_version_file;''')
        file_id = self.cursor.fetchone()[0]

        file = open(upstream_version_file)
        re_upstream_version = re.compile('^([^:]*):([^:]+):([^:]+):(.*)$')
        while True:
            line = file.readline()

            if len(line) == 0:
                break
            if self._is_line_comment(line):
                continue

            match = re_upstream_version.match(line)
            if match:
                modulename = match.group(2)
                version = match.group(3)

                if match.group(1) == 'nonfgo':
                    url = match.group(4)
                elif match.group(1) == 'upstream':
                    url = ''
                else:
                    versions = version.split('.')
                    if len(versions) == 1:
                        majmin = version
                    else:
                        majmin = versions[0] + '.' + versions[1]
                    url = 'http://ftp.gnome.org/pub/GNOME/sources/%s/%s/%s-%s.tar.bz2' % (modulename, majmin, modulename, version)

                self.cursor.execute('''INSERT INTO upstream_version VALUES (
                    NULL, ?, ?, ?, ?
                    );''',
                    (file_id, modulename, version, url))

        file.close()

    def __del__(self):
        self.cursor.close()
        self.db.close()

    def _is_without_upstream(self, name):
        index = name.rfind('branding')
        if index > 0:
            return name[index:] in ['branding-openSUSE', 'branding-SLED', 'branding-SLES']
        return False

    def _get_upstream_name(self, srcpackage):
        self.cursor.execute('''SELECT upstream FROM upstream_name WHERE
            srcpackage = ?;''', (srcpackage,))
        row = self.cursor.fetchone()
        if row:
            return row[0]
        elif self._is_without_upstream(srcpackage):
            return srcpackage
        else:
            return ''

    def _get_upstream_data_from_db(self, upstream_version_file, upstream_name):
        file_id = self._get_upstream_version_file_id(upstream_version_file)
        if not file_id:
            return ('', '')

        self.cursor.execute('''SELECT version, url FROM upstream_version WHERE
            upstream = ? AND upstream_version_file = ?;''', (upstream_name, file_id))
        row = self.cursor.fetchone()
        if row:
            return (row[0], row[1])
        else:
            return ('', '')

    def _get_upstream_version_fallback(self, srcpackage):
        try:
            return self.upstream_versions_fallback[srcpackage]
        except KeyError:
            return ''

    def get_upstream_data(self, upstream_version_file, srcpackage):
        upstream_name = self._get_upstream_name(srcpackage)

        (version, url) = self._get_upstream_data_from_db(upstream_version_file, upstream_name)

        if not version:
            if self._is_without_upstream(upstream_name):
                version = '--'
            else:
                version = self._get_upstream_version_fallback(srcpackage)

        return (upstream_name, version, url)

#######################################################################

class Base:
    sql_table = 'undefined'

    @classmethod
    def sql_setup(cls, cursor):
        pass

    @classmethod
    def sql_lastid(cls, cursor):
        cursor.execute('''SELECT MAX(id) FROM %s;''' % cls.sql_table)
        return cursor.fetchone()[0]

#######################################################################

class File(Base):
    sql_table = 'file'

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            filename TEXT,
            srcpackage INTEGER
            );''' % cls.sql_table)

    def __init__(self, src, name):
        self.filename = name
        self.src_package = src

    def sql_add(self, cursor, srcpackage_id):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL, ?, ?
            );''' % self.sql_table,
            (self.filename, srcpackage_id))

#######################################################################

class Source(Base):
    sql_table = 'source'

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            filename TEXT,
            srcpackage INTEGER,
            nb_in_pack INTEGER
            );''' % cls.sql_table)

    def __init__(self, src, name, i):
        self.filename = name
        self.src_package = src
        self.number = i

    def sql_add(self, cursor, srcpackage_id):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL, ?, ?, ?
            );''' % self.sql_table,
            (self.filename, srcpackage_id, self.number))

#######################################################################

class Patch(Base):
    sql_table = 'patch'

    # Format of tag is: "# PATCH-{FIX|FEATURE}-{OPENSUSE|SLED|UPSTREAM} name-of-file.patch bncb.novell.com_bug_number bgob.gnome.org_bug_number you@example.com -- this patch..."
    # PATCH-NEEDS-REBASE is also a known tag
    # We remove trailing ':' for tags too...
    re_strip_comment = re.compile('^#[#\s]*([\S]*[^:\s]):?\s*(.*)$')
    # anything that looks like something.diff or something.patch
    re_get_filename = re.compile('^\s*(\S+\.(?:diff|patch))\s*(.*)$')
    # anything that looks like word123 or word#123
    re_get_bug_number = re.compile('^\s*([a-zA-Z]+)#?(\d+)\s*(.*)$')
    # anything that looks like a@a
    re_get_email = re.compile('^\s*(\S+@\S+)\s*(.*)$')
    # remove "--" if it's leading the string
    re_get_short_descr = re.compile('^\s*(?:--\s*)?(.*)$')

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            filename TEXT,
            srcpackage INTEGER,
            nb_in_pack INTEGER,
            apply_order INTEGER,
            disabled INTEGER,
            tag TEXT,
            tag_filename TEXT,
            short_descr TEXT,
            descr TEXT,
            bnc INTEGER,
            bgo INTEGER,
            bmo INTEGER,
            bln INTEGER,
            brc INTEGER,
            fate INTEGER,
            cve INTEGER
            );''' % cls.sql_table)

    def __init__(self, src, name, i, disabled=True):
        self.filename = name
        self.number = i
        self.apply_order = -1
        if disabled:
            self.disabled = 1
        else:
            self.disabled = 0
        self.src_package = src
        self.tag = ''
        self.tag_filename = ''
        self.bnc = 0
        self.bgo = 0
        self.bmo = 0
        self.bln = 0
        self.brc = 0
        self.fate = 0
        self.cve = 0
        self.short_descr = ''
#FIXME read the header from the patch itself
        self.descr = ''

    def set_tag(self, tag_line):
        match = Patch.re_strip_comment.match(tag_line)
        if not match:
            return
        self.tag = match.group(1)
        buf = match.group(2)

        match = Patch.re_get_filename.match(buf)
        if match:
            self.tag_filename = match.group(1)
            buf = match.group(2)

        while True:
            match = Patch.re_get_bug_number.match(buf)
            if not match:
                break

            buf = match.group(3)

            if match.group(1) == 'bnc':
                self.bnc = int(match.group(2))
            elif match.group(1) == 'bgo':
                self.bgo = int(match.group(2))
            elif match.group(1) == 'bmo':
                self.bmo = int(match.group(2))
            elif match.group(1) == 'bln':
                self.bln = int(match.group(2))
            elif match.group(1) == 'brc':
                self.brc = int(match.group(2))
            elif match.group(1) == 'fate':
                self.fate = int(match.group(2))
            elif match.group(1) == 'cve':
                self.cve = int(match.group(2))

        match = Patch.re_get_email.match(buf)
        if match:
#FIXME what to do with match.group(1)
            buf = match.group(2)

        match = Patch.re_get_short_descr.match(buf)
        if match:
            self.short_descr = match.group(1)
        else:
            print >> sys.stderr, 'Weird error with patch tag analysis on %s: ' % tag_line
            self.short_descr = buf

    def set_apply_order(self, order):
        self.apply_order = order

    def set_disabled(self, disabled):
        if disabled:
            self.disabled = 1
        else:
            self.disabled = 0

    def sql_add(self, cursor, srcpackage_id):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL, ?, ?, ?, ?, ?,
            ?, ?, ?, ?,
            ?, ?, ?, ?, ?, ?, ?
            );''' % self.sql_table,
            (self.filename, srcpackage_id, self.number, self.apply_order, self.disabled,
             self.tag, self.tag_filename, self.short_descr, self.descr,
             self.bnc, self.bgo, self.bmo, self.bln, self.brc, self.fate, self.cve))

#######################################################################

class RpmlintReport(Base):
    sql_table = 'rpmlint'
    re_rpmlint = re.compile('\s*(.+):\s+(.):\s+(\S+)\s+(\S*)(?:\s+.*)?')
    re_rpmlint_summary = re.compile('\s*\d+\s+packages\s+and\s+\d+\s+spec\s*files\s+checked\s*;')

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            srcpackage INTEGER,
            level TEXT,
            type TEXT,
            detail TEXT,
            descr TEXT
            );''' % cls.sql_table)

    @classmethod
    def analyze(cls, srcpackage, filepath):
        rpmlints = []

        file = open(filepath)

        # read everything until we see the rpmlint report header
        while True:
            line = file.readline()
            if line == '':
                break

            # this is not the beginning of the header
            if line[:-1] != 'RPMLINT report:':
                continue

            # we've found the beginning of the header, so let's read the whole
            # header
            line = file.readline()
            # note: we remove spurious spaces because the build service sometimes add some
            if line[:-1].replace(' ', '') != '===============':
                # oops, this is not what we expected, so go back.
                file.seek(-len(line), os.SEEK_CUR)

            break

        rpmlints_without_descr = []
        descr = None
        separator = True

        # now let's analyze the real important lines
        while True:
            line = file.readline()
            if line == '':
                break

            # empty line: this is either the separator between two series of
            # entries of the same type, or just an empty line.
            # in the former case, this means we'll be able to set the
            # description of the former series and save the series; we just
            # need to be sure we're starting a new series
            if line[:-1] == '':
                separator = True
                continue

            # let's see if this is the end of the rpmlint report, and stop
            # reading if this is the case
            match = cls.re_rpmlint_summary.match(line)
            if match:
                break

            # is this a new entry?
            match = cls.re_rpmlint.match(line)
            if match:
                # we had an old series, so save it
                if separator:
                    if len(rpmlints_without_descr) > 0:
                        for rpmlint in rpmlints_without_descr:
                            rpmlint.descr = descr
                        rpmlints.extend(rpmlints_without_descr)
                        # reset state
                        rpmlints_without_descr = []
                        descr = None
                    separator = False

                package = match.group(1)
                src = package.find('.src:')
                if src > 0:
                    line = package.rstrip()[src + len('.src:'):]
                    try:
                        line = int(line)
                    except:
                        print >> sys.stderr, 'Cannot parse source package line in rpmlint line from %s (%s): %s' % (srcpackage.name, srcpackage.project.name, package)
                        line = None
                else:
                    line = None

                level = match.group(2)
                type = match.group(3)
                detail = match.group(4).strip()
                if line != None:
                    if detail == '':
                        detail = 'line %d' % line
                    else:
                        detail = detail + ' (line %d)' % line

                rpmlints_without_descr.append(RpmlintReport(srcpackage, level, type, detail))
                continue

            # this is not a new entry and not an empty line, so this is the
            # description for the past few rpmlint entries. This is only
            # expected if we had some entries before
            if len(rpmlints_without_descr) == 0:
                print >> sys.stderr, 'Unexpected rpmlint line from %s (%s): %s' % (srcpackage.name, srcpackage.project.name, line[:-1])
                continue

            if descr:
                descr = descr + ' ' + line[:-1]
            else:
                descr = line[:-1]


        if len(rpmlints_without_descr) > 0:
            rpmlints.extend(rpmlints_without_descr)

        file.close()

        return rpmlints

    def __init__(self, srcpackage, level, type, detail):
        self.srcpackage = srcpackage
        self.level = level
        self.type = type
        self.detail = detail
        self.descr = None

    def sql_add(self, cursor, srcpackage_id):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL, ?,
            ?, ?, ?, ?
            );''' % self.sql_table,
            (srcpackage_id,
             self.level, self.type, self.detail, self.descr))

#######################################################################

class Package(Base):
    sql_table = 'package'

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            name TEXT,
            srcpackage INTEGER,
            summary TEXT,
            description TEXT
            );''' % cls.sql_table)

    def __init__(self, src, name):
        self.name = name
        self.src_package = src
        self.summary = ''
#FIXME
        self.description = ''

    def sql_add(self, cursor, srcpackage_id):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL, ?, ?,
            ?, ?
            );''' % self.sql_table,
            (self.name, srcpackage_id,
             self.summary, self.description))

    def set_summary(self, summary):
        # make sure we have utf-8 for sqlite3, else we get
        # sqlite3.ProgrammingError
        try:
            self.summary = summary.encode('utf8')
        except UnicodeDecodeError:
            # we couldn't convert to utf-8: it's likely because we had latin1
            self.summary = summary.decode('latin1')

    def set_description(self, description):
        # see comments in set_summary()
        try:
            self.description = description.encode('utf8')
        except UnicodeDecodeError:
            self.description = description.decode('latin1')

#######################################################################

class SrcPackage(Base):
    sql_table = 'srcpackage'

    re_spec_define = re.compile('^%define\s+(\S*)\s+(\S*)', re.IGNORECASE)
    re_spec_name = re.compile('^Name:\s*(\S*)', re.IGNORECASE)
    re_spec_version = re.compile('^Version:\s*(\S*)', re.IGNORECASE)
    re_spec_summary = re.compile('^Summary:\s*(.*)', re.IGNORECASE)
    re_spec_source = re.compile('^Source(\d*):\s*(\S*)', re.IGNORECASE)
    re_spec_patch = re.compile('^((?:#[#\s]*)?)Patch(\d*):\s*(\S*)', re.IGNORECASE)
    re_spec_package = re.compile('^%package\s*(\S.*)', re.IGNORECASE)
    re_spec_package2 = re.compile('^-n\s*(\S*)', re.IGNORECASE)
    re_spec_lang_package = re.compile('^%lang_package', re.IGNORECASE)
    re_spec_prep = re.compile('^%prep', re.IGNORECASE)
    re_spec_build = re.compile('^%build', re.IGNORECASE)
    re_spec_apply_patch = re.compile('^((?:#[#\s]*)?)%patch(\d*)', re.IGNORECASE)

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            name TEXT,
            project INTEGER,
            srcmd5 TEXT,
            version TEXT,
            link_project TEXT,
            link_package TEXT,
            devel_project TEXT,
            devel_package TEXT,
            upstream_name TEXT,
            upstream_version TEXT,
            upstream_url TEXT,
            is_obs_link INTEGER,
            obs_link_has_delta INTEGER,
            obs_error TEXT,
            obs_error_details TEXT
            );''' % cls.sql_table)

    @classmethod
    def sql_lastid(cls, cursor):
        cursor.execute('''SELECT MAX(id) FROM srcpackage;''')
        return cursor.fetchone()[0]

    def __init__(self, name, project, parent_directory):
        self.path = os.path.join(parent_directory, name)

        self.name = name
        self.project = project
        self.srcmd5 = ''
        self.version = ''

        self.upstream_name = ''
        self.upstream_version = ''
        self.upstream_url = ''

        self.packages = []
        self.sources = []
        self.patches = []
        self.files = []
        self.rpmlint_reports = []

        self.link_project = ''
        self.link_package = ''
        self.devel_project = ''
        self.devel_package = ''

        # not booleans, since sqlite doesn't support this
        self.is_link = 0
        self.has_delta = 0
        self.error = ''
        self.error_details = ''

        self._analyze_files()
        self._analyze_specs()
        self._get_rpmlint_errors()

    def sql_add(self, cursor, project_id):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL,
            ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
            );''' % self.sql_table,
            (self.name, project_id, self.srcmd5, self.version, self.link_project, self.link_package, self.devel_project, self.devel_package, self.upstream_name, self.upstream_version, self.upstream_url, self.is_link, self.has_delta, self.error, self.error_details))

    def read_data(self, db_cache):
        if not db_cache:
            return

        (self.upstream_name, self.upstream_version, self.upstream_url) = db_cache.get_upstream_data(self.project.versionfile, self.name)

    def _analyze_files(self):
        linkfile = os.path.join(self.path, '_link')
        if os.path.exists(linkfile):
            self.is_link = 1

            try:
                root = ET.parse(linkfile).getroot()
            except SyntaxError, e:
                print >> sys.stderr, 'Cannot parse %s: %s' % (linkfile, e.msg)
            else:
                node = root.find('patches')
                if node is not None:
                    if node.find('delete') != None or node.find('apply') != None:
                        self.has_delta = 1

        files = os.path.join(self.path, '_files-expanded')
        if not os.path.exists(files):
            files = os.path.join(self.path, '_files')
        if os.path.exists(files):
            try:
                root = ET.parse(files).getroot()
            except SyntaxError, e:
                print >> sys.stderr, 'Cannot parse %s: %s' % (files, e.msg)
            else:
                self.srcmd5 = root.get('srcmd5')
                linkinfo = root.find('linkinfo')
                if linkinfo != None:
                    link_project = linkinfo.get('project')
                    if link_project:
                        self.link_project = link_project
                    link_package = linkinfo.get('package')
                    if link_package:
                        self.link_package = link_package

                    error = linkinfo.get('error')
                    if error:
                        if error.find('does not exist in project') != -1:
                            self.error = 'not-in-parent'
                        elif error.find('could not apply patch') != -1:
                            self.error = 'need-merge-with-parent'
                        self.error_details = error

                for node in root.findall('entry'):
                    filename = node.get('name')
                    if filename in IGNORE_FILES:
                        continue
                    self.files.append(File(self, filename))

    def _analyze_specs(self):
        if not self.path:
#FIXME verbose
            #print >> sys.stderr, '%s: cannot analyze spec because there\'s no path' % self.name
            return

#FIXME: maybe have SpecPackage between SrcPackage and Package? For libxml2, we have two times the upstream tarball as source because we have two spec files. This also means we write self.version twice
        for file in self.files:
            if file.filename[-5:] == '.spec':
                self._analyze_spec(os.path.join(os.sep, self.path, file.filename))

    def _analyze_spec(self, filename):
        '''Analyze a spec file and extract the relevant data from there'''
        if not os.path.exists(filename):
            # FIXME: print warning?
            return

        spec = open(filename)

        current_package = None
        defines = {}
        defines['name'] = self.name

        def subst_defines(s, defines):
            '''Replace macros like %{version} and %{name} in strings. Useful
               for sources and patches '''
            for key in defines.keys():
                if s.find(key) != -1:
                    value = defines[key]
                    s = s.replace('%%{%s}' % key, value)
                    s = s.replace('%%%s' % key, value)
            return s

        # to help if Summary is defined before Name
        early_summary = False

        line = 'empty'
        while True:
            # we need to remember the previous line for patch tags
#FIXME: some packages have comments on two lines...
            previous_line = line
            line = spec.readline()
            if line == '':
                break

            match = SrcPackage.re_spec_prep.match(line)
            if match:
                break

            match = SrcPackage.re_spec_define.match(line)
            if match:
                defines[match.group(1)] = match.group(2)
                continue

            match = SrcPackage.re_spec_name.match(line)
            if match:
                name = match.group(1)
                defines['name'] = name
                current_package = Package(self, match.group(1))
                if early_summary:
                    # if we had a summary before the name, then use it now
                    current_package.set_summary(early_summary)
                    early_summary = None
                self.packages.append(current_package)
                continue

            match = SrcPackage.re_spec_lang_package.match(line)
            if match:
                current_package = Package(self, defines['name'] + '-lang')
                self.packages.append(current_package)
                continue

            match = SrcPackage.re_spec_package.match(line)
            if match:
                pack_line = subst_defines(match.group(1), defines)
                match = SrcPackage.re_spec_package2.match(pack_line)
                if match:
                    current_package = Package(self, match.group(1))
                else:
                    current_package = Package(self, defines['name'] + '-' + pack_line)
                self.packages.append(current_package)
                continue

            match = SrcPackage.re_spec_version.match(line)
            if match:
                # Ignore version if it's redefined for a second package.
                # Test case: MozillaThunderbird.spec, where the main package
                # has a version, and the enigmail subpackage has another
                # version.
                if self.version and len(self.packages) > 1:
                    continue

                self.version = subst_defines(match.group(1), defines)
                defines['version'] = self.version
                continue

            match = SrcPackage.re_spec_summary.match(line)
            if match:
                if not current_package:
                    # save the summary for later
                    early_summary = match.group(1)
                    continue
                current_package.set_summary(match.group(1))
                continue

            match = SrcPackage.re_spec_source.match(line)
            if match:
                if match.group(1) == '':
                    nb = '0'
                else:
                    nb = match.group(1)
                buf = subst_defines(match.group(2), defines)
                source = Source(self, buf, nb)
                self.sources.append(source)
                continue

            match = SrcPackage.re_spec_patch.match(line)
            if match:
                # we don't need it here: we'll explicitly mark the patches as
                # applied later
                disabled = (match.group(1) != '')
                if match.group(2) == '':
                    nb = '0'
                else:
                    nb = match.group(2)
                buf = subst_defines(match.group(3), defines)
                patch = Patch(self, buf, nb)
                patch.set_tag(previous_line)
                self.patches.append(patch)
                continue

        order = 0
        while True:
            line = spec.readline()
            if line == '':
                break

            match = SrcPackage.re_spec_build.match(line)
            if match:
                break

            match = SrcPackage.re_spec_apply_patch.match(line)
            if match:
                disabled = (match.group(1) != '')
                if match.group(2) == '':
                    nb = '0'
                else:
                    nb = match.group(2)
                for patch in self.patches:
                    if patch.number == nb:
                        patch.set_disabled(disabled)
                        patch.set_apply_order(order)
                        break
                order = order + 1
                continue

        spec.close()

    def _get_rpmlint_errors(self):
        if not RPMLINT_ERRORS_PATH or RPMLINT_ERRORS_PATH == '':
            return

        filepath = os.path.join(os.sep, RPMLINT_ERRORS_PATH, self.project.name, self.name + '.log')
        if not os.path.exists(filepath):
            return

        self.rpmlint_reports = RpmlintReport.analyze(self, filepath)

    def __str__(self):
        ret = ''
        ret = ret + "Name: %s\n" % self.name
        ret = ret + "Upstream name: %s\n" % self.upstream_name
        ret = ret + "Packaged version: %s\n" % self.version
        ret = ret + "Upstream version: %s\n" % self.upstream_version
        #ret = ret + "Path: %s\n" % self.path
        ret = ret + "Sources:\n"
        for source in self.sources:
            ret = ret + "  %s\n" % source.filename
        ret = ret + "Patches:\n"
        for patch in self.patches:
            ret = ret + "  %s: %s\n" % (patch.number, patch.filename)
        ret = ret + "Packages:\n"
        for package in self.packages:
            ret = ret + "  %s\n" % package.name
        ret = ret + "%d rpmlint errors\n" % len(self.rpmlint_reports)
        return ret

#######################################################################

class Project(Base):
    sql_table = 'project'

    @classmethod
    def sql_setup(cls, cursor):
        cursor.execute('''CREATE TABLE %s (
            id INTEGER PRIMARY KEY,
            name TEXT,
            parent TEXT,
            ignore_upstream INTEGER,
            toplevel INTEGER
            );''' % cls.sql_table)

    def __init__(self, name, parent_directory):
        self.name = name
        self.parent_directory = parent_directory
        self.srcpackages = []
        self.parent = ''
        self.versionfile = ''
        # not boolean, since sqlite doesn't support this
        self.toplevel = 0

        self.meta_devel = {}
        self._read_config()

    def sql_add(self, cursor):
        cursor.execute('''INSERT INTO %s VALUES (
            NULL, ?, ?, ?, ?
            );''' % self.sql_table,
            (self.name, self.parent, self.versionfile == '', self.toplevel))

    def _read_config(self):
        project_dir = os.path.join(self.parent_directory, self.name)

        config_file = os.path.join(project_dir, 'obs-checkout-meta')
        if not os.path.exists(config_file):
            return

        file = open(config_file)
        lines = file.readlines()
        file.close()

        for line in lines:
            line = line[:-1]
            if line.startswith('parent='):
                parent = line[len('parent='):]
                if parent == self.name:
                    parent = ''
                    self.toplevel = 1
                else:
                    self.toplevel = 0
                self.parent = parent

            elif line.startswith('versionfile='):
                versionfile = line[len('versionfile='):]
                if not versionfile:
                    self.versionfile = ''
                    continue

                if os.path.exists(versionfile):
                    self.versionfile = versionfile
                else:
                    print >> sys.stderr, 'Version file specified in %s does not exist: %s' % (config_file, versionfile)

            else:
                print >> sys.stderr, 'Unknown config option in %s: %s' % (config_file, line)

    def _read_meta(self):
        project_dir = os.path.join(self.parent_directory, self.name)

        meta_file = os.path.join(project_dir, 'obs-checkout-pkgmeta')
        if not os.path.exists(meta_file):
            return

        try:
            collection = ET.parse(meta_file).getroot()
        except SyntaxError, e:
            print >> sys.stderr, 'Cannot parse %s: %s' % (meta_file, e.msg)
            return

        for package in collection.findall('package'):
            name = package.get('name')
            if not name:
                continue

            devel = package.find('devel')
            # "not devel" won't work (probably checks if devel.text is empty)
            if devel == None:
                continue

            devel_project = devel.get('project', '')
            if not devel_project:
                continue
            devel_package = devel.get('package', '')

            self.meta_devel[name] = (devel_project, devel_package)

    def read_srcpackages(self, db_cache):
        project_dir = os.path.join(self.parent_directory, self.name)
        if not os.path.exists(project_dir):
            return

        self._read_meta()

        if self.versionfile:
            db_cache.fill_upstream_version(self.versionfile)

        for file in os.listdir(project_dir):
            if file in ['obs-checkout-meta', 'obs-checkout-pkgmeta']:
                continue

            srcpackage = SrcPackage(file, self, project_dir)
            srcpackage.read_data(db_cache)

            if self.parent and not srcpackage.is_link and not srcpackage.error:
                srcpackage.error = 'not-link'

            if self.meta_devel.has_key(srcpackage.name):
                (srcpackage.devel_project, srcpackage.devel_package) = self.meta_devel[srcpackage.name]

            self.srcpackages.append(srcpackage)

        del self.meta_devel
        self.meta_devel = {}

#######################################################################

class CreateDbException(Exception):

    def __init__(self, value):
        self.msg = value

    def __str__(self):
        return repr(self.msg)

class CreateDb:

    def __init__(self, filename, force):
        self.dbconn = None
        self.cursor = None

        if not force and os.path.exists(filename):
            raise CreateDbException('%s already exists.' % filename)

        self.filename = filename
        # We prefer a temp file that has a predictable name so we don't fill
        # the disk in case of issues.
        #(fout, self.tmpfilename) = tempfile.mkstemp(dir = os.path.)
        #fout.close()
        self.tmpfilename = filename + '.tmp'
        if os.path.exists(self.tmpfilename):
            os.unlink(self.tmpfilename)

        self.dbconn = sqlite3.connect(self.tmpfilename)
        self.dbconn.row_factory = sqlite3.Row
        self.dbconn.text_factory = sqlite3.OptimizedUnicode
        self.cursor = self.dbconn.cursor()

        self._create_tables()

    def __del__(self):
        self.close()

    def _create_tables(self):
        self.cursor.execute('''CREATE TABLE db_version (
            major INTEGER,
            minor INTEGER
            );''')
        self.cursor.execute('''INSERT INTO db_version VALUES (
            ?, ?
            );''', (DB_MAJOR, DB_MINOR))

        Project.sql_setup(self.cursor)
        SrcPackage.sql_setup(self.cursor)
        Package.sql_setup(self.cursor)
        Source.sql_setup(self.cursor)
        Patch.sql_setup(self.cursor)
        File.sql_setup(self.cursor)
        RpmlintReport.sql_setup(self.cursor)

        self.dbconn.commit()

    def add_project(self, project):
        project.sql_add(self.cursor)
        project_id = Project.sql_lastid(self.cursor)

        for srcpackage in project.srcpackages:
            srcpackage.sql_add(self.cursor, project_id)
            srcpackage_id = SrcPackage.sql_lastid(self.cursor)

            for package in srcpackage.packages:
                package.sql_add(self.cursor, srcpackage_id)
                package_id = Package.sql_lastid(self.cursor)

            for rpmlint in srcpackage.rpmlint_reports:
                rpmlint.sql_add(self.cursor, srcpackage_id)

            for source in srcpackage.sources:
                source.sql_add(self.cursor, srcpackage_id)

            for patch in srcpackage.patches:
                patch.sql_add(self.cursor, srcpackage_id)

            for file in srcpackage.files:
                file.sql_add(self.cursor, srcpackage_id)

        # It's apparently not needed to commit each time to keep a low-memory
        # profile, and committing is slowing things down.
        #self.dbconn.commit()

    def analyze_for_errors(self):
        '''
            Do some post-commit analysis on the db, to find new errors now that
            we have all the data.
        '''

        def _not_link_and_not_in_parent(cache, cursor_helper, row):
            '''
                Check if this is not a link and if it doesn't exist in the
                potential parent. In that case, the error is that maybe it
                should exist there
            '''
            if row['obs_error'] != 'not-link':
                return False

            project_parent = row['project_parent']
            if not project_parent:
                return False

            try:
                cache[project_parent][row['name']]
            except KeyError:
                error = 'not-link-not-in-parent'
                details = ''
                cursor_helper.execute('''UPDATE %s SET obs_error = ?, obs_error_details = ? WHERE id = ?;''' % SrcPackage.sql_table, (error, details, row['id']))
                return True

            return False

        def _not_real_devel_package(cache, cursor_helper, row):
            '''
                Look if the link package should really exist there (ie, is it
                the devel package of the parent?)
            '''
            # the errors here are not relevant to toplevel projects
            if row['toplevel_project'] != 0:
                return False

            link_project = row['link_project']
            link_package = row['link_package'] or row['name']

            # internal link inside a project (to build another spec file)
            if link_project == row['project']:
                return False

            try:
                (devel_project, devel_package) = cache[link_project][link_package]
                if devel_project != row['project'] or devel_package != row['name']:
                    if devel_project:
                        error = 'not-real-devel'
                        details = 'development project is %s' % devel_project
                    else:
                        error = 'parent-without-devel'
                        details = ''
                    cursor_helper.execute('''UPDATE %s SET obs_error = ?, obs_error_details = ? WHERE id = ?;''' % SrcPackage.sql_table, (error, details, row['id']))
                    return True

            except KeyError:
                # this happens when the parent package doesn't exist; link will
                # be broken, so we already have an error
                pass

            return False


        cache = {}
        cursor_helper = self.dbconn.cursor()

        self.cursor.execute('''SELECT name FROM %s;''' % Project.sql_table)
        for row in self.cursor:
            cache[row['name']] = {}

        self.cursor.execute('''SELECT A.name, A.devel_project, A.devel_package, B.name AS project FROM %s AS A, %s AS B WHERE A.project = B.id;''' % (SrcPackage.sql_table, Project.sql_table))
        for row in self.cursor:
            devel_package = row['devel_package'] or row['name']
            cache[row['project']][row['name']] = (row['devel_project'], devel_package)

        self.cursor.execute('''SELECT A.id, A.name, A.obs_error, A.link_project, A.link_package, B.name AS project, B.parent AS project_parent, B.toplevel AS toplevel_project FROM %s AS A, %s AS B WHERE A.project = B.id;''' % (SrcPackage.sql_table, Project.sql_table))
        for row in self.cursor:
            if _not_link_and_not_in_parent(cache, cursor_helper, row):
                continue

            if _not_real_devel_package(cache, cursor_helper, row):
                continue

        cursor_helper.close()

    def close(self):
        if self.cursor:
            self.cursor.close()
            self.cursor = None
        if self.dbconn:
            self.dbconn.commit()
            self.dbconn.close()
            self.dbconn = None

        if self.tmpfilename:
            # this overwrites the old file if needed
            os.rename(self.tmpfilename, self.filename)
            self.tmpfilename = None


def main(args):
    parser = optparse.OptionParser()

    parser.add_option("-o", "--output-database", dest="outputdb",
                      help="output sqlite database file")
    parser.add_option("-d", "--checkout-dir", dest="checkout_dir",
                      default=PACKAGE_LOOKUP_PATH,
                      help="directory where the projects have been checked out")
    parser.add_option("-u", "--upstream-name", dest="upstream_name",
                      default=MODULE_SRCPACKAGE_MATCH_FILE,
                      help="file containing the mapping between upstream and package names")
    parser.add_option("--upstream-versions-fallback", dest="upstream_versions_fallback",
                      default=UPSTREAM_VERSIONS_FALLBACK_FILE,
                      help="file containing upstream versions for packages, that will be used as a fallback if no upstream version is available in the main database")
    parser.add_option("-f", "--force", action="store_true", dest="force",
                      default=False, help="overwrite files if already existing")

    (options, args) = parser.parse_args()

    if not options.outputdb:
        options.outputdb = os.path.join(OBS_DISSECTOR_DIR, 'obs.db')
        print 'No database file specified; using %s.' % options.outputdb

    if not options.force and os.path.exists(options.outputdb):
        print >> sys.stderr,  '%s already exists. You can use --force to overwrite it.' % options.outputdb
        return

    db_cache = DataCache(options.upstream_name, options.upstream_versions_fallback)
    try:
        db = CreateDb(options.outputdb, options.force)
    except CreateDbException, e:
        print >> sys.stderr,  e.msg
        return

    for file in os.listdir(options.checkout_dir):
        if not os.path.isdir(os.path.join(options.checkout_dir, file)):
            continue
        project = Project(file, options.checkout_dir)
        project.read_srcpackages(db_cache)
        db.add_project(project)
        del project

    del db_cache

    db.analyze_for_errors()

    db.close()


if __name__ == '__main__':
    try:
      main(sys.argv)
    except KeyboardInterrupt:
      pass
