#!/usr/bin/python
# vim: set ts=4 sw=4 et: coding=UTF-8

#
# Copyright (c) 2008, Novell, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#  * Neither the name of the <ORGANIZATION> nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#
# (Licensed under the simplified BSD license)
#
# Authors: Vincent Untz <vuntz@novell.com>
#

# TODO:
#  + Support checking out a project/package in a already existing checkout.
#    This implies that we handle an "update" operation, in case the package
#    is already checked out.
#
#  + With the new handling of link packages, we don't have to download the
#    "parent" package anymore. So stop doing it.
#    Instead, provide a simple way with command line arguments to download
#    all packages in GNOME:Factory from openSUSE:Factory.
#    This means the usual use case will be:
#      ./obs-checkout GNOME:Factory
#      ./obs-checkout --packages-of GNOME:Factory openSUSE:Factory
#    Note that this might imply that we move the "stable directory" handling
#    out of this script.
#
#  + Add a feature to automatically detect collaboration branches.

import os
import sys

import optparse
import shutil
import subprocess
import tempfile
import urllib2

try:
    from xml.etree import cElementTree as ET
except ImportError:
    import cElementTree as ET

from osc import conf
from osc import core

from dissector_util import *
from osc_extend import *

# We will check out everything in CHECKOUT_DIR_PARENT/$some_dir where $some_dir
# is based on CHECKOUT_DIR_PREFIX and some random data.
CHECKOUT_DIR_PARENT = '/tmp/obs-dissector'
CHECKOUT_DIR_PREFIX = 'obs-co-'

if os.getenv('OBS_DISSECTOR_DIR') and os.getenv('OBS_DISSECTOR_DIR') != '':
    CHECKOUT_DIR_PARENT=os.getenv('OBS_DISSECTOR_DIR')

# This is the directory (as a symlink) that can be used by outside programs
# when the checkout is complete. This means it will always contain complete &
# consistent data.
CHECKOUT_DIR_STABLE = os.path.join(CHECKOUT_DIR_PARENT, CHECKOUT_DIR_PREFIX + 'stable')

# This is the project that is usually parent of everything else. It will be
# used as a default value.
DEFAULT_PARENT_PROJECT = 'openSUSE:Factory'


#######################################################################


conf_initialized = False


def osc_conf_init():
    global conf_initialized

    if not conf_initialized:
        try:
            conf.get_config()
            conf_initialized = True
        except oscerr.NoConfigfile, e:
            print >>sys.stderr, e.msg
            sys.exit(1)


#######################################################################


class ObsCheckout:
    def __init__(self, dest_dir, cache_dir = None):
        osc_conf_init()

        self.dest_dir = dest_dir
        if dest_dir != cache_dir:
            self.cache_dir = cache_dir
        else:
            print >>sys.stderr, 'Ignoring specified cache directory that is also the destination directory'


    def _get_file_metadata_from_cache(self, project, package, filename):
        if not self.cache_dir:
            return (None, None)

        files = os.path.join(self.cache_dir, project, package, '_files-expanded')
        if not os.path.exists(files):
            files = os.path.join(self.cache_dir, project, package, '_files')
            if not os.path.exists(files):
                return (None, None)

        try:
            root = ET.parse(files).getroot()
        except SyntaxError:
            return (None, None)

        for node in root.findall('entry'):
            if node.get('name') == filename:
                return (node.get('md5'), node.get('mtime'))

        return (None, None)


    def _get_file(self, project, package, filename, md5, mtime, revision = None):
        package_dir = os.path.join(self.dest_dir, project, package)
        destfile = os.path.join(package_dir, filename)

        # first try to copy the file from the cache
        (cached_md5, cached_mtime) = self._get_file_metadata_from_cache(project, package, filename)
        if md5 == cached_md5 and mtime == cached_mtime:
            cached_file = os.path.join(self.cache_dir, project, package, filename)
            if os.path.exists(cached_file):
                shutil.copyfile(cached_file, destfile)
                return

        # couldn't copy the file from the cache, so download it
        try:
            core.get_source_file(conf.config['apiurl'], project, package, filename, destfile, revision)
        except urllib2.HTTPError, e:
            print >>sys.stderr, 'Could not get file ' + filename + ' for ' + package + ' from ' + project + ': ' +  + e.msg


    def _get_files_metadata(self, project, package, save_basename, revision = None):
        package_dir = os.path.join(self.dest_dir, project, package)
        filename = os.path.join(package_dir, save_basename)

        # if we already have the files metadata, this means we've already been
        # there in some way (because we're downloading multiple times something
        # in openSUSE:Factory, eg -- it can happen if a package exists in both
        # GNOME:Factory and mozilla:Factory)
        # In this case, we have nothing to do.
        if os.path.exists(filename):
            return None

        # download files metadata
        try:
            metadata = core.show_files_meta(conf.config['apiurl'], project, package, revision)
        except urllib2.HTTPError, e:
            if revision:
                print >>sys.stderr, 'Ignoring ' + package + ' from ' + project + ' with specified revision: ' + e.msg
            else:
                print >>sys.stderr, 'Ignoring ' + package + ' from ' + project + ': ' + e.msg
            return None

        f = open(filename, 'w')
        f.write(''.join(metadata))
        f.close()

        return ET.parse(filename).getroot()


    def checkout_package(self, project, package):
        package_dir = os.path.join(self.dest_dir, project, package)
        safe_mkdir_p(package_dir)

        # find files we're interested in from the metadata
        root = self._get_files_metadata(project, package, '_files')
        if not root:
            return

        # detect if the package is a link package
        linkinfos_nb = len(root.findall('linkinfo'))
        linkinfo = EasyLinkinfo()
        if linkinfos_nb == 1:
            linkinfo.read(root.find('linkinfo'))
        elif linkinfos_nb > 1:
            print >>sys.stderr, 'Ignoring link in' + package + ' from ' + project + ': more than one <linkinfo>'

        # this will be None if it's not a link that matters and else, this will
        # be the right value to expand the link
        revision = linkinfo.xsrcmd5

        if linkinfo.needshandling():
            root = self._get_files_metadata(project, package, '_files-expanded', revision)
            if not root:
                return

        # look at all files and download what might be interesting
        for node in root.findall('entry'):
            filename = node.get('name')
            md5 = node.get('md5')
            mtime = node.get('mtime')
            # download .spec files
            if filename.endswith('.spec'):
                self._get_file(project, package, filename, md5, mtime, revision)


    def _checkout_packages_from_project(self, project, packages):
        for package in packages:
            self.checkout_package(project, package)


    def checkout_project_packages_existing_in_project(self, project, existing_in_project):
        try:
            packages = core.meta_get_packagelist(conf.config['apiurl'], existing_in_project)
        except urllib2.HTTPError, e:
            print >>sys.stderr, 'Ignoring packages from ' + existing_in_project + ' for project ' + project +': ' + e.msg
            return

        self._checkout_packages_from_project(project, packages)


    def checkout_project(self, project):
        try:
            packages = core.meta_get_packagelist(conf.config['apiurl'], project)
        except urllib2.HTTPError, e:
            print >>sys.stderr, 'Ignoring project' + project +': ' + e.msg
            return

        self._checkout_packages_from_project(project, packages)


    def checkout_project_with_parent(self, project, parent_project = DEFAULT_PARENT_PROJECT):
        if project != parent_project:
            self.checkout_project_packages_existing_in_project(parent_project, project)
        self.checkout_project(project)


def find_stable_directory():
    if os.path.lexists(CHECKOUT_DIR_STABLE):
        if not os.path.islink(CHECKOUT_DIR_STABLE):
            print >>sys.stderr, 'Broken setup: ' + CHECKOUT_DIR_STABLE + 'is not a symbolic link'
            sys.exit(1)
        return os.readlink(CHECKOUT_DIR_STABLE)
    else:
        return None


def make_stable_directory(directory, old_stable_directory):
    if os.path.lexists(CHECKOUT_DIR_STABLE):
        if not os.path.islink(CHECKOUT_DIR_STABLE):
            print >>sys.stderr, 'Broken setup: ' + CHECKOUT_DIR_STABLE + 'is not a symbolic link anymore'
            sys.exit(1)
        elif os.readlink(CHECKOUT_DIR_STABLE) != old_stable_directory:
            print 'The stable directory has been updated while we were downloading data. Cancelling everything...'
            shutil.rmtree(directory)
            sys.exit(0)
        os.unlink(CHECKOUT_DIR_STABLE)

    os.symlink(directory, CHECKOUT_DIR_STABLE)

    # Do this after symlinking the new directory: doing it before would just
    # delay the access to the latest data
    if old_stable_directory != None:
        shutil.rmtree(old_stable_directory)


def main(args):
    parser = optparse.OptionParser()

    parser.add_option("-n", "--no-parent", action="store_true",
                      dest="no_parent", default=False,
                      help="download packages from the projects, with no download of packages from a parent project")
    parser.add_option("-p", "--project", action="append", dest="projects",
                      default=[],
                      help="projects to check out")

    (options, args) = parser.parse_args()

    if len(options.projects) == 0:
        projects = [ 'GNOME:Factory' ]
    else:
        # use set to make sure we don't do something twice
        projects = set(options.projects)

    # We check everything out in a temporary directory.
    # At the end, we'll symlink this directory to the stable directory, and
    # remove the old checkout. This way, we always have a valid & working
    # stable checkout.

    checkout_dir_stable = find_stable_directory()
    checkout_dir_current = tempfile.mkdtemp('', CHECKOUT_DIR_PREFIX, CHECKOUT_DIR_PARENT)

    co = ObsCheckout(checkout_dir_current, checkout_dir_stable)

    for project in projects:
        if options.no_parent:
            co.checkout_project(project)
        else:
            co.checkout_project_with_parent(project)

    make_stable_directory(checkout_dir_current, checkout_dir_stable)


if __name__ == '__main__':
    try:
      main(sys.argv)
    except KeyboardInterrupt:
      pass
