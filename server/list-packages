#!/usr/bin/env python
# vim: set ts=4 sw=4 et: coding=UTF-8

#
# Copyright (c) 2008, Novell, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#  * Neither the name of the <ORGANIZATION> nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
#
# (Licensed under the simplified BSD license)
#
# Authors: Vincent Untz <vuntz@opensuse.org>
#

import os
import sys

import cStringIO as StringIO
import errno
import optparse
import sqlite3
import urllib2

try:
    from lxml import etree as ET
except ImportError:
    try:
        from xml.etree import cElementTree as ET
    except ImportError:
        import cElementTree as ET

from osc import conf
from osc import core
from osc import oscerr

conf_initialized = False

#FIXME: should probably live in util, and we'd import it
def _copy_stderr_without_ssl(buffer):
    """ Copy the content of a string io to stderr, except for the SSL warning. """
    buffer.seek(0)
    ignore_empty = False
    while True:
        line = buffer.readline()
        if len(line) == 0:
            break
        if line == 'WARNING: SSL certificate checks disabled. Connection is insecure!\n':
            ignore_empty = True
            continue
        if line == '\n' and ignore_empty:
            ignore_empty = False
            continue
        ignore_empty = False
        print >>sys.stderr, line[:-1]


def osc_conf_init():
    global conf_initialized

    if not conf_initialized:
        # Workaround to remove warning coming from osc.conf when we don't use
        # SSL checks
        buffer = StringIO.StringIO()
        oldstderr = sys.stderr
        sys.stderr = buffer

        try:
            conf.get_config()
            conf_initialized = True
        except oscerr.NoConfigfile, e:
            sys.stderr = oldstderr
            buffer.close()
            print >>sys.stderr, e.msg
            sys.exit(1)

        # Workaround to remove warning coming from osc.conf when we don't use
        # SSL checks
        sys.stderr = oldstderr
        _copy_stderr_without_ssl(buffer)
        buffer.close()


def get_db_conn(filename):
    create_tables = not os.path.exists(filename)
    dbconn = sqlite3.connect(filename)
    dbconn.row_factory = sqlite3.Row
    cursor = dbconn.cursor()

    if create_tables:
        cursor.execute('''CREATE TABLE projects (
            id INTEGER PRIMARY KEY,
            project TEXT
            );''')
        # we don't use an ID for the packages since they get removed/add all
        # the time and they should stay unique anyway thanks to the project_id
        cursor.execute('''CREATE TABLE packages (
            project_id INTEGER,
            package TEXT
            );''')

    return (dbconn, cursor)


def drop_old_projects(cursor, new_projects):
    cursor.execute('''SELECT * FROM %s;''' % 'projects')
    rows = cursor.fetchall()
    for row in rows:
        if row['project'] not in new_projects:
            cursor.execute('''DELETE FROM %s WHERE project_id = ?;''' % 'packages', (row['id'],))
            cursor.execute('''DELETE FROM %s WHERE project = ?;''' % 'projects', (row['project'],))


# Create the project in the database if it's not already there
def get_project_id(cursor, project):
    def get_existing_id(cursor, project):
        cursor.execute('''SELECT id FROM %s WHERE project = ?;''' % 'projects', (project,))
        row = cursor.fetchone()
        if row:
            return row['id']
        else:
            return None

    id = get_existing_id(cursor, project)
    if id:
        return id

    cursor.execute('''INSERT INTO %s VALUES (NULL, ?);''' % 'projects', (project,))
    id = get_existing_id(cursor, project)
    return id

def update_project(cursor, project, try_again = True):
    # Note: we don't remove the old packages (or create the project if it
    # wasn't already there) until we were able to parse the XML. This way, in
    # case of error, we keep the old data

    try:
        url = core.makeurl(conf.config['apiurl'], ['source', project])
        fd = urllib2.urlopen(url)

        directory = ET.parse(fd).getroot()
        if int(directory.get('count')) < 1:
            fd.close()
            if try_again:
                update_project(cursor, project, False)
            else:
                print >>sys.stderr, 'Ignoring project %s: %s' % (project, 'no package? Sounds like an error...')
            return

        project_id = get_project_id(cursor, project)
        if not project_id:
            print >>sys.stderr, 'Ignoring project %s: %s' % (project, 'no project in the database')
            fd.close()

        # empty the project
        cursor.execute('''DELETE FROM %s WHERE project_id = ?;''' % 'packages', (project_id,))

        # insert the packages
        for node in directory.findall('entry'):
            cursor.execute('''INSERT INTO %s VALUES (?, ?);''' % 'packages', (project_id, node.get('name')))

        fd.close()

    except urllib2.HTTPError, e:
        if try_again:
            update_project(cursor, project, False)
        else:
            print >>sys.stderr, 'Ignoring project %s: %s' % (project, e.msg)
    except urllib2.URLError, e:
        if try_again:
            update_project(cursor, project, False)
        else:
            print >>sys.stderr, 'Ignoring project %s: %s' % (project, e)
    except SyntaxError, e:
        if try_again:
            update_project(cursor, project, False)
        else:
            print >>sys.stderr, 'Ignoring project %s: %s' % (project, e.msg)


def update_projects(cursor, projects):
    for project in projects:
        update_project(cursor, project)


def main(args):
    parser = optparse.OptionParser()

    parser.add_option("-d", "--output-database", dest="outputdb",
                      help="output sqlite database file")

    (options, args) = parser.parse_args()

    if not options.outputdb:
#FIXME error
        return

#FIXME: should just import our util
    try:
        os.makedirs(os.path.dirname(options.outputdb))
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise e

    # 'DISCONTINUED:openSUSE:10.2', 'DISCONTINUED:openSUSE:10.2:Update', 'openSUSE:10.3:Update', 'openSUSE:11.0:Update', 'openSUSE:10.3', 'openSUSE:11.0', 'openSUSE:11.1', 'openSUSE:11.1:Update', 'GNOME:STABLE:2.26', 'openSUSE:11.2', 'openSUSE:11.2:Update', 'openSUSE:11.2:Contrib', 'GNOME:STABLE:2.28'
    projects = [ 'openSUSE:Factory', 'openSUSE:Factory:Contrib', 'GNOME:Factory', 'GNOME:Apps', 'GNOME:Contrib', 'GNOME:STABLE:2.30', 'GNOME:STABLE:2.32', 'openSUSE:11.3', 'openSUSE:11.3:Update', 'openSUSE:11.3:Contrib', 'openSUSE:11.4', 'openSUSE:11.4:Update', 'openSUSE:11.4:Contrib', 'GNOME:STABLE:3.0' ]

    osc_conf_init()

    (dbconn, cursor) = get_db_conn(options.outputdb)

    drop_old_projects(cursor, projects)
    update_projects(cursor, projects)

    dbconn.commit()
    cursor.close()
    dbconn.close()

if __name__ == '__main__':
    try:
      main(sys.argv)
    except KeyboardInterrupt:
      pass
